#### 1. 배열, 문자열

배열 : 여러 개의 동일한 데이터 타입의 데이터를 한번에 만들때 사용.

참조 시 주소로 참조

배열의 주소 : 첫 번째 인덱스의 주소. -> 배열의 이름이 상수 포인터의 역할을 함.



배열의 장점 : 빠른 접근, 데이터 관리 편함.

단점 : 메모리 공간 낭비, 동적 관리 힘듦.



2차원 배열 -> 가로줄을 행, 세로줄을 열 

우리 생각으로는 표 모양 -> 실제로는 일자로 쭉



문자열 

char가 단어 1개밖에 담지 못해서, 문자를 표현하기위해 char형 배열을 사용함. (c언어에서는 따로 자료형 x)

이때 글자 수 + \0 (NULL문자 , 문장의 끝)으로 저장.

이후 많은 언어에서 그냥 string으로 문장을 표현할 수 있게 됨.

String 역시 기본은 char형 배열 느낌이라, 글자 하나 하나를 인덱스 형식으로 참조 할 수 있음.

ex)  charAt(int index), indexOf(char a) (java)





#### 2. 연결리스트

 각 노드가 데이터와 포인터를 가지고 연결되어 있는 방식으로 데이터 저장.

노드 : 단위

노드안에 데이터 + 포인터

첫번째 노드를 가르키고 있는 변수(포인터) = 헤드 포인터



필요할 때마다 노드를 동적으로 생성하여 연걸할 수 있음.

실제 메모리 상에선 연속적이지 않아도 상관 x



주요 연산 (단일 연결 리스트)

삽입  

중간에 삽입할 시, 삽입 할 노드의 next 가 그 앞 노드의 next 가르키게 한 뒤 헤드를 삽입할 노드로 변경

맨 뒤에는 그냥 맨 마지막에의 next 바꾸기

삭제 

중간에서 삭제 시 삭제할 노드의 next를 그 앞 노드가 가르키게 함.

맨 뒤에서는 그냥 맨 마지막의 next = null

탐색

헤드에서부터 순차적으로 탐색할 수 밖에 없음.

단일 연결 리스트 / 이중 연결 리스트/ 원형 연결 리스트등이 존재.



#### 3. 스택, 큐 덱

Stack : 후입선출형 구조. 맨 마지막에 들어온 애가 맨 처음으로 나감. (LIFO)

입력과 출력을 한 방향에서 제한한 자료구조.

top으로 맨 위 표시.

함수 호출에서 복귀 주소를 기억하는데 사용, DFS에서도 사용 가능.

pop -> 맨 위 요소 뽑아오기 / peek -> 맨 위에 요소의 값만 얻어오기 / push -> 스택에 값 넣기.



Queue : 선입선출형 구조. 나중에 들어온 데이터가 먼저 나감. 

한쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조.

삽입이 일어나는 곳을 후단(rear), 삭제가 일어나는 곳을 전단(front)라고 함.

컴퓨터와 주변 기기 사이에서 사용, 순서대로 일을 스케쥴링 할때 사용. BFS에서도 사용.

enqueue -> 큐의 맨 뒤 요소 추가, dequeue -> 큐의 앞에 있는 요소 뽑아오기,



환형 큐 : front와 rear의 값이 배열의 끝에 도달하면, 다시 0으로 되도록 하는 것. 

이때 front는 항상 큐의 첫번째 요소의 앞을, rear는 마지막 요소를 가르킴

이때  꼭 한자리를 비워놔야함. (공백과 포화를 구분하기 위함)

front == rear 면 공백상태, 

front가 rear보다 하나 앞에 있으면 포화상태. (front % size == rear +1 % size)



우선순위 큐

우선순위별로 정렬되어 있는 형태. 주로 Heap으로 구현.

가장 우선순위가 높은 노드가 먼저 dequeue됨.



덱 양쪽 끝에서 모두 자료를 넣고 뺄 수 있는 자료구조.(Double ended queue -> Deque)

front 와 rear(후단)으로 나누어져 앞뒤에서 입,출력 가능






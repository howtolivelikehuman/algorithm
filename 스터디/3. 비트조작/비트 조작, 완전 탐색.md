#### 1. 비트 조작

비트(bit)는 Binary Digit를 줄인 말로 데이터를 나타내는 최소 단위이다. 0과 1 두 값 중 하나를 가질 수 있다.

8bit가 모여서 1Byte가 되며 이후 단위들은 아래와 같다.

| 접두어(SI) | 이름                      | 계산법     | 접두어(IEC) | 이름                        | 계산법       |
| ---------- | ------------------------- | ---------- | ----------- | --------------------------- | ------------ |
| 킬로(103)  | 1킬로바이트(kilobyte)/kB  | 1000B=1kB  | 키비(210)   | 1키비바이트(kibibyte)/KiB   | 1024B=1KiB   |
| 메가(106)  | 1메가바이트(megabyte)/MB  | 1000KB=1MB | 메비(220)   | 1메비바이트(mebibyte)/MiB   | 1024KiB=1MiB |
| 기가(109)  | 1기가바이트(gigabyte)/GB  | 1000MB=1GB | 기비(230)   | 1기비바이트(gibibyte)/GiB   | 1024MiB=1GiB |
| 테라(1012) | 1테라바이트(terabyte)/TB  | 1000GB=1TB | 테비(240)   | 1테비바이트(tebibyte)/TiB   | 1024GiB=1TiB |
| 페타(1015) | 1페타바이트(petabyte)/PB  | 1000TB=1PB | 페비(250)   | 1페비바이트(pebibyte)/PiB   | 1024TiB=1PiB |
| 엑사(1018) | 1엑사바이트(exabyte)/EB   | 1000PB=1EB | 엑사(260)   | 1엑스비바이트(exbibyte)/EiB | 1024PiB=1EiB |
| 제타(1021) | 1제타바이트(zettabyte)/ZB | 1000EB=1ZB | 제비(270)   | 1제비바이트(zebibyte)/ZiB   | 1024EiB=1ZiB |
| 요타(1024) | 1요타바이트(yottabyte)/YB | 1000ZB=1YB | 요비(280)   | 1요비바이트(yobibyte)/YiB   | 1024ZiB=1YiB |

실제로는 킬로, 메가 기가 등등 모두 $2^{10}$으로 계산한다.



이러한 비트 조작은 비트연산자를 통해 계산할 수 있다.

* NOT (~)

  각 자리수의 값을 반대로 바꾸는 연산. 

  (NOT 1010 = 0101  	 x = ~x)

* OR (|)

  두 자릿수 중 하나라도 1이 있으면 1로, 없으면 0으로 하는 연산

  1010 OR 0101 = 1111 	X = X|Y

* AND

  두 자릿수 중 하나라도 0이 있으면 0으로, 없으면 1로 하는 연산

  1010 AND 0101 = 0000 	 X = X&Y

* XOR

  두 자릿수의 값이 다르면 1, 같으면 0으로 하는 연산

  1010 XOR 0101 = 1111 	X = X^Y;

  

시프트 연산

시프트 연산은 비트들의 자릿수를 이동시키는 것으로 두 가지 종류가 있다.



산술 시프트 

">> n " 면 오른쪽으로, "<< n"면 왼쪽으로 비트를 n 칸씩 이동 시키는 것이다. 

만약 범위를 초과하게 되면 초과 자릿수는 소멸되고, 빈 자릿수는 0으로 채워진다. 

하지만 정수의 부호는 바뀌지 않는다. 만약 오른쪽 시프트일때 ( >> ) 음수면 최상위 비트가 1이고, 이때는 자릿수를 1로 채운다.



논리 시프트

">>> n" 이면 오른쪽으로 , "<<< n"이면 왼쪽으로 비트를 n칸씩 회전시키는 것이다.

범위를 초과하게 되면 초과 자릿수는 다시 빈 자릿수로 채워진다.

보통 암호 알고리즘에 주로 사용되는데, 직접 구현해야 할 필요가 많다.

````c
#define RotateR(word , bit) (((word) >> (bit)) | ((word) << (32-(bit))))
````

">>>" 를  부호 없는 정수 범위에서 산술 시프트와 OR를 사용하여 구현한 모습인데

bit만큼 오른쪽으로 >>한 값과 32-bit만큼 왼쪽으로 << 한 값을 or연산하여 회전 시킨 모습이다.

00000000001111111111010101010101 >>> 12

= 00000000000000000000001111111111 | 01010101010100000000000000000000 = 01010101010100000000001111111111



그렇다면 비트 연산의 특징을 알아보자.

1. 어느 숫자를 $2^n$만큼 곱하는 것은 n만큼 "<<" 하는 것과 같다.

   5*4 = 0101 << 2 = 10100 (20)

   반대로 $2^n$ 만큼 나누는 것은 n만큼 ">>"하는 것과 같다.

2. 어느 숫자에 어느 숫자건 xor을 두 번 취하면 원래 숫자로 돌아간다.

   0101 ^ 1010 = 1111 ^ 1010 = 0101

   이러한 특성을 이용하여 대칭 암호 알고리즘에 주로 사용된다.

3. 1111111.... = ~0이다.

   이러면 프로그램이 32bit인지, 64bit인지 신경쓰지 않고도 사용할 수 있다. 

   ~11 = 111111111....00,  



비트 조작 함수들

GET : 특정 비트 얻어내기

````
int getBit(int number, int i){
	return number & (1 << i); // number | (0 << i)도 가능
}
````

SET : 특정 위치의 비트값 채우기 (1로)

````
int setBit(int number, int i){
	return number | (1 << i);
}
````

CLEAR : 특정 위치의 비트 값 삭제하기 (0으로)

````
int clearBit(int number, int i){
	return (number & ~(1 << i));
}
````

CLEAR2 : 특정 위치부터 0까지 모두 삭제하기

````
int clearBitthroughI(int number, int i){
	return (number & (~0 << i+1));
}
````

UPDATE : 특정 위치의 비트 값 반전

````
int updateBit(int number, int i){
	return number ^ (1 << i);
}
````





#### 2. 완전탐색

완전 탐색은 모든 경우의 수를 다 해보는 것으로 Brute Force라고도 한다.

컴퓨터의 빠른 계산 능력을 이용하여 모든 경우의 수를 해보지만, 시간 역시 최대로 소모된다.

for문을 사용하여 정말 모든 경우를 탐색하는 방법과, 재귀, DFS/BFS/ 백트래킹, 비트마스크 등이 존재한다.

위와 같은 방법들을 간단하게 소개하도록 하겠다.



재귀 : 어느 함수가 자기 자신을 다시 참조하는 방법이다. 

$f(n) = f(n-1) + f(n-2)$ 등의 피보나치 수열, $n! = (n-1)! * n$ 과 같은 팩토리얼 연산 등에서 자주 등장한다.

하지만 재귀함수는 잘못 사용하면 복잡도가 어마어마하고, 함수가 끝날 때까지 자기 자신 호출 이후의 명령문이 수행되지 않는다.

또한 반드시 종료조건이 있어야 무한루프를 방지할 수 있다.



백트래킹 : 한국말로 퇴각검색이라고 하는데, 어느 경로(노드)를 탐색할 때 가망이 없으면 이전으로 돌아가(부모 노드) 다시 탐색하는 방법이다.



DFS/BFS : 둘다 그래프에서 경로를 탐색하는 방법으로 DFS 는 깊이 우선 탐색(Depth-First-Search), BFS는 너비 우선 탐색 (Breadth-First-Search)이다.

DFS는 사실상 백트래킹을 사용한 기법으로 한가지 경로를 끝까지 탐색한 후, 이전 분기점으로 되돌아가 다시 탐색해보는 방법이고,

BFS는 갈 수 있는 모든 경로를 한 번씩 탐색하고 다음 분기점으로 넘어가는 방식이다.



비트마스크 : 자료 구조를 사용하지 않고, 간단하게 집합 등의 요소들을 표현하고 연산하는 방법.

1000000개를 담을 크기의 배열을 만들어야 하는데, 단순히 T/F만 표현하고자 하면, 굳이 배열을 만들 필요없이 000.....00으로 표현하고 

위의 비트 연산등을 통해 적절한 위치에 1과 0으로 바꿔주면 된다.





#### 동적 프로그래밍

동적 계획법(dynamic programing)은 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다.



사실 동적 프로그래밍이라는 명칭과 실제 의미가 별로 연관성이 없어 보이는데, 동적 계획법을 처음 발표한 벨만은

공군 소속의 회사에 근무하던 벨만은 당시 연구를 하는 것을 극도로 싫어하던 국방 위원장 윌슨의 눈을 피해 

문제 풀이 절차를 프로세스(process) 대신 (programming)으로 숨겨서 표기했다고 한다. 이 프로세스가 다단계로 이루어져있고, 동적이기 때문에

동적 계획법 (Dynamic Programming)이 된 것이다.



사실 작은 문제를 나눈다는 것은 분할정복(Divide and Conquer)와 비슷하다고 생각 할 수  있다. 여기서 두 방법 모두 큰 문제를 작게 나누어서 해결하는 점은 동일히지만, 동적 계획법은 같은 문제가 반복된다는 점이 다르다. 여기서 동적 계획법의 핵시민 메모이제이션이 등장한다.

메모이제이션은 작은 문제가 똑같이 반복되는 동적 계획법에서, 작은 문제의 결과값을 한군데 저장해놓고, 다시 사용하는 방법이다.

위의 피보나치 문제(사진)에서 예를 들면,  f(n)이 f(n-1) 과 f(n-2)를 호출하고, f(n-1)은 f(n-2)와 f(n-3)을, f(n-2)는 f(n-3)과 f(n-4)를 호출하는데,

여기서 f(n)과 f(n-1)을 제외하고는 나머지 연산들은 반복되어 등장함을 알 수 있다.  이 결과값들은 저장해두었다가 다시 사용함으로써 동적 계획법은 시간복잡도를 확실하게 줄일 수 있다.



동적 프로그래밍 전략

사실 나도 동적 프로그래밍을 어떻게 써먹어야 할 지 처음에는 감이 잘 오지않았다. (물론 지금도 오지 않는다.)

그러다 참고하게 된 "알고리즘 문제해결전략"에서의 동적 프로그래밍 레시피는 아래와 같다.

> 1. 모든 답을 만들어 보고 최적해의 점수를 반환하는 완전 탐색 알고리즘 설계
> 2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만 반환하도록 부분문제 바꾸기
> 3. 재귀 호출의 입력에 이전에 선택에 관련된 정보가 있다면 필요한 것만 남기고 줄이기. 가능한 한 중복문제 줄이기
> 4. 문제가 최적 부분 구조면 이전 선택 정보들 아예 없애는 것도 가능.
> 5. 입력이 배열이거나 문자열이면 적절한 변환으로 메모제이션 적용.



문제를 푸는 방법 Top down vs Bottom up

가장 큰 문제에서 작은 문제를 호출해서 찾는 방식 (재귀 사용)

작은 문제부터 답을 구해가며 전체 문제의 답을 찾음



피보나치에서의 Top down

````java
public void Fibonacci(int n){
    if(n == 0) return 0;
    if(n == 1) return 1;
    
    if(cache[n] != 1) return cache[n];
    cache[n] = Fibonacci(n-1) - Fibonacci(n-2); 
}
````



Bottom up

````java
public void Fibonacci(int n){
    cache[0] = 0; cache[1] = 1;
    for(int i=2 i<=n; i++){
        cache[i] = cache[i-1] + cache[i-2]
    }
    
    if(cache[n] != 1) return cache[n];
    cache[n] = Fibonacci(n-1) - Fibonacci(n-2); 
}
````



보통 Top-down은 문제를 풀때 점화식에서 유추해내기 쉽고, Bottom up은 반복문 등의 간단한 구조로 시간과 메모리를 줄일 수 있다. 


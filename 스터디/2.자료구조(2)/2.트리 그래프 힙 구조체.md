#### 1. 트리, 그래프



##### 트리 = 노드(node)로 이루어진 자료구조

하나의 루트 노드 존재.

루트 노드로부터 0개 이상의 자식 노드들 존재, 이런 노드들이 서브트리(sub tree)를 구성.

루트와 서브 트리, 노드들 간는 간선(edge)으로 연결

트리 = acyclic undirected(connected) Graph, 사이클이 없고 방향이 없는 그래프.

* 루트 노드 (Root node) : 부모가 없는 노드 (트리의 처음)
* 잎 노드 (Leaf node) : 자식이 없는 노드 (트리의 마지막들)
* 부모 노드(Parent node) , 자식 노드(Child node)의 관계가 있음
* 노드의 깊이(Depth) : 루트노드(0)으로부터 도달하기 위해 거쳐야 하는 간선의 수 (부모 노드의 깊이 +1)								
* 노드의 높이(Height) : 루트 노드로부터 가장 큰 깊이
* 노드의 차수(Degree) : 각 노드가 지닌 가지의 개수(자식의 개수)





이진트리 = 각 노드들이 최대 두개의 자식 노드를 가지는 트리 구조. 서브트리 역시 이진트리를 구성함.

트리 순회 : 트리의 모든 노드들을 중복 없이 방문하는 방법

전위순회 : N - l - r

중위순회 : L- n - R

후위순회 : L - R - n

이진트리 공식

1. n개의 노드일때 간선 n-1개 간선
2. 깊이가 d 일때 높이 최대 $2^d$
3. 높이가 h일때 노드 최대 $2^{h+1}-1$개 
4. n개의 노드일때 최소 높이 $\lceil{lg(n+1)\rceil -1} $ 



완전 이진 트리

트리의 모든 높이에서 노드가 꽉 차있는 이진 트리. 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워짐.

이진 트리는 배열을 사용하여 루트 노드가 1부터 시작한다고 할 때, 그 자식 노드들은 부모 노드 *2, *2+1한 인덱스에 위치하는 방법으로 표현할 수 있음.

연결 리스트로 표현 할 때에는, 양방향 리스트로 왼쪽, 오른쪽 포인터로 자식 노드를 가르키는 방법으로 표현할 수 있음.



이진 탐색 트리

이진 트리 기반으로 탐색을 효율적으로 수행하기 위한 트리. 

모든 노드의 키는 유일, 왼쪽 서브 트리의 키들은 루트보다 작고, 오른쪽 서브 트리의 키는 루트보다 큰 트리.

왼쪽, 오른쪽 서브트리 역시 모두 이진 탐색 트리.



##### 그래프 = 정점(vertices)의 모음과 이 정점을 잇는 간선(edge)의 모음

$G = (V,E)$로 표현, 이때 부분그래프 $G` = (V`,E`)$ 일때 $V`\subseteq V$ , $E`\subseteq E$

완전 그래프 (Complete Graph) 모든 정점이 나머지 정점에 간선이 있는 형태. 

두 정점간 간선이 연결(incident)된 경우 , 두 정점은 접하고 있다 (adjacent), 인접해 있다(neighbors)라고 함.

경로(path) = 그래프 G 안의 정점$V_1$ 에서 다른 정점 $V_2$로 갈때 거쳐야 하는 정점들

비 방향성 그래프 (Undirected Graph) = 연결(connected)되어 있음 (방향 x) 

방향성 그래프(Directed Graph) = 강하게 연결(strongly conneceted)되어 있음. (방향 o)

사이클(Cycle) = 그래프 G에서 자기 자신으로 돌아오는 경로가 있는 경우. / Acyclic = 사이클이 없음

2차원 배열로 각 정점 간 간선을 표현할 수 있고, 연결리스트로 표현 시 포인터로 각 정점을 연결하여 구현할 수 있음.

그래프의 간선별로 가중치를 넣은 가중 그래프도 있음. 이때 최단 경로를 찾는 프림, 다익스트라, 크루스칼 알고리즘등이 존재.



#### 2. 힙

힙은 이진 트리에서 특정한 조건을 이룬 구조이다.

1. 이진 트리 T의 높이가 h라고 할때 h-1까지 완전 이진 트리이다. 
2. 모든 잎 노드는 깊이가 h나 h-1이다.
3. 깊이 h의 모든 잎 노드들의 경로는 h-1의 모든 잎 노드보다 왼쪽에 있다.



부분 순서 트리(Partial order tree) 모든 노드가 자식 노드보다 값이 크거나 같은 트리 $key(parent)\geq key(child)$

-> 완전 순서 트리 (Total order tree) 정렬된 트리.

이진 탐색 트리에서는 중복된 값 x , 힙에서는 가능.

부모가 자식의 키 값보다 작은 최대 히프(max heap), 부모가 자식 노드보다 작은 최소 히프 (min heap) 두 종류 존재.

배열로 구현 시 역시 루트 노드가 1부터 시작한다고 할 때, 그 자식 노드들은 부모 노드 *2, *2+1한 인덱스에 위치하는 방법으로 표현할 수 있음.



힙 삽입과정

````
heap_size = heap_size +1;

i = heap_size;

A[i] =key (A에서 i번째 맨 마지막에 키 삽입)

while i != 1 and A[i] > A[PARENT] do
	swap (A[i],A[PARENT])
	i = A[PARENT]
````

힙 삭제과정

````
item = A[l]	//루트 노드를 반환하여 item에 담음
A[l] = A[heap_size]	//말단 노드를 루트 노드로 옮김
heap_size = heap_size-1
i = 2;	
while i<= heap_size do	// 다시 힙을 구축하는 과정.
	if i<heap_size and A[i+1] > A[i]	//자식들 중 큰 자식을 찾기
		then largest = i+1;
		else largest = i
	if A[PARENT(largest)] > A[largest]	//부모가 더 크면 중지
		then break;
	swap (A[PARENT(largest)],A[largest])	//아니면 부모와 교환후
	i = CHILD(largest)	//다음 레벨 진행
return item
````



### 3. 구조체

여러가지 다른 타입의 데이터들을 한데 묶어 놓는 자료형. C/ C#계열에서는 struct 키워드로 선언 후 사용.

java에서는 따로 없음.

구조체와 클래스 차이점.

클래스 : 참조형 / 구조체 : 값형 -> 클래스는 참조복사, 구조체는 내용 복사

클래스 객체는 힙에 저장, 구조체 객체는 스택에 저장

구조체는 상속 불가능, 

구조체 소멸자 x

구조체 멤버는 초기값을 가질 수 없음.







